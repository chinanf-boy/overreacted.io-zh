---
title: 我的 热加载 愿望单
date: '2018-12-08'
spoiler: 我不想要圣诞节。 这里是我唯一需要的东西。
---

你有一个项目，你反复在成功和失败之间，兜兜转转，暂时搁置一段时间，然后再次尝试 - 年复一年? 对于某些人来说，它可能是路由器或虚拟列表滚动器。对我来说，是热重载(hot reloading)。

我第一次接触到动态更改代码的想法，是在我十几岁时，读到的一本关于 Erlang 的书中简要提到的。很久以后，和其他许多人一样，我爱上了[Bret Victor’s 美丽演示](https://vimeo.com/36579366)。我在某个地方读到，Bret 对于人们仅挑他演示的"简单"部分，却扭曲了大视野而感到不满。(我不知道这是不是真的。)**在任何一种情况下，对我来说，‘运输’甚至人们认为应该的小量改进都是成功的。**比我聪明的人会为 Next Big Ideas(下一个大想法) 而工作。

现在，我想清楚申明，在这篇文章中讨论的*思路*都不是我的。我受到许多项目与人的[启发](https://redux.js.org/#thanks)。事实上，即使那些我从未尝试过的项目也偶尔会告诉我，我已经帮他们解脱了。

我不是发明家。如果说我有一个"原则(principle)"，那就是一种愿景，在激励我，并通过文字，代码和演示与更多人分享。

热重载(hot reloading)愿景激励着我。

---

我已经多次尝试为 React 实现热重载。

回想起来，我拼凑起来的[第一次演示](https://vimeo.com/100010922)改变了我的生活。它让我获得了第一批推特粉丝，首先是 1000 GitHub stars，接着第一次上[HN 首页](https://news.ycombinator.com/item?id=8982620)，甚至是我的第一个[会议谈话](https://www.youtube.com/watch?v=xsSnOQynTHs)(带来了 Redux 存在，哎呀)。第一次迭代工作得相当好。然而，很快 React 就*离开*了`createClass`，这使可靠的实现变得更加困难。

从那时起，我就完成了[一些尝试](https://medium.com/@dan_abramov/hot-reloading-in-react-1140438583bf?source=user_profile---------6------------------)来修复它，每个都存在不同的缺陷方式。其中一个仍然在 React Native 中使用(因为我的错误，热重载功能在那里不起作用 - 抱歉!)

接着吧，我开始因无法解决一些问题，和时间不够而感到沮丧，我将 React Hot Loader 交给了一些有才华的贡献者。他们一直在推动它，并为我的设计缺陷找到了巧妙的解决方法。尽管面临挑战，我仍然感谢他们让项目保持良好状态。

---

**需要说明的是，React 中的热重载在今天非常有用。**事实上，这个博客使用 Gatsby，它就使用了 React Hot Loader。我在我的编辑器中，保存了这篇文章，它的(页面)更新是不需要刷新的。魔法啊! 在某些方面，我对不能广泛使用的担忧想法，现在看来已变得无聊。

但，有很多人觉得它没有那么好。有些人认为它是一种噱头且让我心碎了一点，但我认为他们真正说的是:**这种体验并非天衣无缝。**如果您不确定热重载是否有效，是否会以困惑方式崩溃，或者是否能更容易的(仅做)刷新，那说明就是还不够好。我 100%同意，但对我而言，这意味着我们还有更多的工作要做。我很高兴开始考虑 React 对热重载的官方支持，将来会是什么样子。

(如果你使用像 Elm，Reason 或 ClojureScript 这样的语言，也许这些问题已经在你的生态系统中得到解决。我很高兴你很高兴。但这不会阻止我尝试为 JavaScript 带来好处。)

---

我想，我已准备好，再次尝试实现它了。下面就是原因。

自从我们定义组件的主要方式`createClass`停止了，**热重载组件中最大复杂性与脆弱性，就是动态替换类方法。**如何使用这些方法的新"版本"修补现有的类实例? 简单的答案是"在原型上替换它们"，但即便使用 Proxies，根据我的经验，为了让它可靠地工作有太多的边缘情况.

相比之下，热重载函数很容易。Babel 插件可以将从模块导出的任何函数组件，拆分为两个函数:

```jsx
// 重新分配 最新的版本
window.latest_Button = function(props) {
  // 你的实际代码被一个插件移到这里
  return <button>Hello</button>
}

// 把这当作“代理”
// 其他组件将使用
export default function Button(props) {
  // 始终指向最新版本
  return window.latest_Button(props)
}
```

每次编辑后该模块重新执行，`window.latest_Button`都会指出最新的实现。在模块计算之间，重用相同的`Button`函数，将使我们能够巧妙地做到，即使我们交换了实现，React 也不会卸载组件。

有段很长时间，在我看来，*单独*为函数实现可靠的热重载，会鼓励人们编写复杂的代码，从而避免使用类。但随着[Hooks](https://reactjs.org/docs/hooks-intro.html)函数组件功能的齐全，所以这不再是一个问题。这种方法"仅适用于"Hooks:

```jsx{4}
// 重新分配最新版本
window.latest_Button = function(props) {
  // 你的实际代码被一个插件移到这里
  const [name, setName] = useState('Mary')
  const handleChange = e => setName(e.target.value)
  return (
    <>
      <input value={name} onChange={handleChange} />
      <h1>Hello, {name}</h1>
    </>
  )
}

// 把这当作“代理”
// 其他组件将使用
export default function Button(props) {
  // 始终指向最新版本
  return window.latest_Button(props)
}
```

只要 Hook 调用顺序没有改变，即使`window.latest_Button`在文件编辑期间替换掉了，我们也可以保持状态。并且替换的事件处理程序也能"工作" - 因为 Hook 依赖于闭包，而我们替换了整个函数。

---

这只是一种可能方法的粗略草图。还有更多(有些是非常不同的)。那我们如何评估和比较它们?

在我过于依赖，某个在某种程度上存在缺陷的具体方法之前，**我决定写下一些我认为，对评定组件代码的热重载实现，很重要的原则。**

将这些原则中的一些，作为稍后的测试会很好。这些规则并不严格，也可能存在合理的妥协。但是，如果我们真的决定打破它们，那应该作为一个明确的设计决定，而不是我们后来再亡羊补牢。

这里是我的热重载 React 组件的愿望单:

### 正确性

- **在第一次编辑之前，热重载应该是不可观察的。**在保存文件之前，代码的行为应与禁用热重载时的行为完全相同。预计会有类似的`fn.toString()`的东西不匹配，这已经是缩小了的边缘情况。但，它不应该破坏合理的应用程序和库逻辑。

- **热重载不应该破坏 React 规则。**组件不应该以意外的方式，调用它们的生命周期，在不相关的树之间意外地交换状态，或者执行其他 非-Reacty 事务.

- **元素类型应始终与预期类型匹配。**一些方法包装组件类型，但这可能会破坏`<MyThing />.type === MyThing`。这是错误的常见来源，不应该发生.

- **应该很容易支持所有 React 类型。** `lazy`，`memo`，`forwardRef`- 他们都应该得到支持，并且不应该很难添加更多的支持。嵌套的变体如`memo(memo(...))`也应该工作。我们应该在类型形状发生变化时，重载(remount)。

- **它不应该重新实现一个不正常的 React 块。** React 的步伐很难跟上。如果一个解决方案重新实现 React，它会在长期内带来问题，因为 React 增加了像 Suspense 这样的功能。

- **再导出不应该破坏。**如果组件从其他模块(无论是自己还是来自`node_modules`)重新导出组件，那么这不应该有问题。

- **静态字段不应该破坏。**如果你定义一个`ProfilePage.onEnter`方法，您希望导入的模块能够读取它。有时，库也会依赖于这个，因此重要的是，能够读和写静态属性，和组件本身可以"看到"相同的值。

- **丢失局部状态比行为不正确更好。**如果我们无法牢固地修补某些东西(例如，一个类)，最好丢失它的局部状态，而不是更改它为一个胡乱的成功结果。无论如何，开发人员终会怀疑，并且可能会强制刷新浏览器。我们应该有意识地确定，我们可以处理哪些情况，并放弃其余的情况。

- **丢失局部状态比使用旧版本更好。**这是先前原则的更具体的变化。例如，如果某个类无法热重载，则代码应该强制使用新版本重载这些组件，而不是继续渲染一条'咸鱼'。

### 局部性

- **编辑模块应该尽可能少地重新执行模块。**通常不鼓励在组件模块初始化期间产生副作用。但是你执行的代码越多，两次调用导致混乱的可能性就越大。我们正在编写 JavaScript，而 React 组件是(相对)纯粹的岛屿，但即便如此，我们也不能强而有力的保证。因此，如果我编辑模块，我的热重载解决方案应该重新执行该模块，并尝试在可能的情况下，停止。

- **编辑组件不应该破坏其父母或兄弟姐妹的状态。**与`setState()`只影响下面树的方式类似，编辑组件不应该影响它上面的任何内容。

- **对非 React 代码的编辑应该向上传播。**如果编辑文件中从多个组件导入的常量或纯函数，则应更新这些组件。在这些文件中丢失模块状态是可以接受的。

- **热重载期间引入的运行时错误不应传播。**如果你在一个组件中犯了错误，它不应该破坏你的整个应用程序。在 React 中，这常用错误边界来解决。然而，它们对于我们在编辑时，产生的无数错别字来说太粗糙了。在没有兄弟姐妹或父母卸载的情况下，处理组件时，我应该确定能修复运行时错误。但是，错误*别*在热重载期间发生(且是我的代码中的合法错误)，应该转到最接近的错误边界。

- **保留自己的状态，除非显然开发人员不想这样做。**如果您只是调整样式，那么状态会在每次编辑时都要重置，就很烦人。另一方面，如果你只是改变了状态形状或初始状态，你通常会喜欢它重置。但默认情况下，我们应该尽力保持住状态。若它在热重载期间导致错误，这通常是假设已经改变了些东西的迹象，所以我们应该重置状态和在那种情况下*重新尝试*渲染。对事物进行评论和回顾是很常见的，因此优雅地处理它是很重要的。例如，删除 *末尾的*Hooks 不应该重置状态。

- **当开发人员想要清楚时，丢弃状态。**在某些情况下，我们还可以主动检测用户是否想要重置。例如，如果 Hook 顺序改变了，或者原始 Hook 类似`useState`改变他们的初始状态类型。我们还可以提供一个轻量级注释，您可以使用它来强制组件在每次编辑时重置。如`// !`或者一些类似的约定，当您专注于组件装载时，可以快速添加和删除。

- **支持更新"修复了"的东西。**如果组件被`memo()`包裹，热重载应该仍然更新它。如果用`[]`调用效果，它仍应该能被替换。代码就像一个看不见的变量。以前，我认为强制执行深层更新，下面类似的`renderRow={this。renderRow}`事情非常重要。但是在 Hooks 世界中，我们依赖闭合，无论如何这看起来都是不必要的。一个不同的引用应该就足够了。

- **在一个文件中支持多个组件。**在同一文件中定义多个组件是一种常见模式。即使我们只保留函数组件的状态，我们也希望确保，即便将它们放在一个文件中，也不会导致它们失去状态。注意这些可以是相互递归的。

- **在可能的情况下，保持孩子的状钛。**如果你编辑一个组件，如果它的孩子无意中失去了状态，这样挺烦人的。只要在其他文件中，定义了子元素的元素类型，我们就希望保留它们的状态。如果它们都在同一个文件中，我们应该尽最大努力维护。

- **支持自定义 Hooks。**对于精心编写的自定义 Hooks(有些情况如`useInterval()`可能有点棘手)，热重载任何参数(包括函数)应该工作。这不应该需要额外的工作，而是从 Hooks 的设计中得出.我们的解决方案不应该妨碍到。

- **支持渲染 props。**这通常不会造成问题，但验证它们是否正常工作，并按预期更新，是值得的。

- **支持更高阶的组件。**将导出包装到更高阶的组件中，如`connect`不应该破坏热重载或状态保存。如果您使用从 JSX 中的 HOC 创建的组件(例如`styled`)，并且该组件是一个类，那预计，它在编辑文件中实例化时就会丢失状态。但是，返回函数组件(可能使用 Hooks)的 HOC 即使在同一文件中定义，也不应丢失状态。事实上，甚至编辑它(例如`mapStateToProps`)的参数应该也被反映出来。

### 反馈

- **成功和失败都应该提供视觉反馈。**您应该始终明确热重载是成功还是失败。在运行时或语法错误的情况下，您应该看到一个覆盖页面(关于错误)，它应该在搞定之后自动取消。当热重载成功时，应该有一些视觉反馈，例如刷新更新的组件或通知。

- **语法错误不应导致运行时错误或刷新。**当您编辑代码时，如果有语法错误，它应该显示在覆盖模式中(理想情况下，通过点击编辑器)。如果出现另一个语法错误，则会更新现有覆盖页面。仅在你修复语法错误*之后*尝试热重载。语法错误不应使您失去状态。

- **重新加载后的语法错误应该仍然可见。**如果您看到模式语法错误覆盖页面之后，去刷新页面，那么您仍然应该看到它。它绝对不应该让你运行上一个成功的版本(我在一些设置中看到过)。

- **考虑公开超级用户工具。**通过热重载，代码本身可以是您的"终端"。除了假设`// !`命令强制重载(mount)，例如`// inspect`命令显示一个面板，该面板在组件旁边具有 props 值。发挥你的创造力!

- **尽量减少噪音。**devtools 和警告消息不应该公开我们正在做一些特殊的事情。避免微碎的`displayName`或者在调试输出中添加无用的包装器。

- **在主要浏览器中，调试应该显示最新的代码。**虽然这并不完全取决于我们，但我们应该尽最大努力确保浏览器调试器显示任何文件的最新版本，并且，断点按预期工作.

- **优化快速迭代，不需要长时间重构。**这是 JavaScript，不是 ELM.任何长时间运行的系列编辑都可能不会很好地热重载，因为需要一个接一个地修复一系列错误。如果有疑问，请针对在紧密迭代循环中，调整几个组件的用例进行优化，而不是针对大型重构进行优化。这样还是可以预测的。请记住，如果您失去了开发人员的信任，他们无论如何都会去刷新。

---

这是我的愿望清单，说明是如何在 React 或任何提供超过模板的组件系统中，热重载 ，这应该工作。随着时间的推移，我可能会在这里添加更多的内容.

我不知道我们可以用 JavaScript 实现多少目标。但还有一个原因，我期待着重新编写热重载。作为一名工程师，我较以前的我来说，更强了。特别是，**在深入到另一个实现之前，我终于学到了如何编写这样的需求的经验。**

也许这个真的能用! 但，如果没有，至少我为下一个尝试它的人留下了一些'老面'。
