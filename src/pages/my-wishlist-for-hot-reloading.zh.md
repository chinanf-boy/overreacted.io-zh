---
title: 我的 热加载 白名单
date: '2018-12-08'
spoiler: 我不想要太多圣诞节. 这里是我需要的唯一东西.
---

你有一个项目,你反复接近成功和失败的混合,暂时搁置一段时间,然后再次尝试 - 年复一年?对于某些人来说,它可能是路由器或虚拟列表滚动器.对我来说,这是热重装.

我第一次接触到动态更改代码的想法是在一本关于 Erlang 的书中简要提到我在十几岁时读到的.很久以后,和其他许多人一样,我爱上了[Bret Victor’s beautiful demos](https://vimeo.com/36579366).我读过某个地方,布雷特对于人们对他演示的"简单"部分进行挑选并搞砸了大视野感到不满.(我不知道这是不是真的.)**在任何一种情况下,对我来说,运输甚至人们认为理所当然的小额增量改进都是成功的.**比我聪明的人会为 Next Big Ideas 工作.

现在,我想清楚一点都没有*思路*在这篇文章中讨论的是我的.我去过[inspired](https://redux.js.org/#thanks)许多项目和人.事实上,即使那些我从未尝试过的项目偶尔会告诉我,我已经扯掉了他们的东西.

我不是发明家.如果我有一个"原则",那就是采取一种激励我的愿景,并通过文字,代码和演示与更多人分享.

热重装激励着我.

---

我已经多次尝试为 React 实现热重新加载.

回想起来,[the first demo](https://vimeo.com/100010922)我拼凑起来改变了我的生活.它让我成为了我的第一批推特追随者,首先是一千个 GitHub 明星[HN frontpage](https://news.ycombinator.com/item?id=8982620)打了,甚至是我的第一个[conference talk](https://www.youtube.com/watch?v=xsSnOQynTHs)(带来 Redux 存在,哎呀).第一次迭代工作得相当好.然而,很快 React 感动了*远*从`createClass`,使可靠的实施更加困难.

从那时起我就完成了[a few more attempts](https://medium.com/@dan_abramov/hot-reloading-in-react-1140438583bf?source=user_profile---------6------------------)修复它,每个都以不同的方式存在缺陷.其中一个仍然在 React Native 中使用(由于我的错误,热重新加载功能在那里不起作用 - 抱歉!)

由于我无法解决一些问题和时间不够而感到沮丧,我将 React Hot Loader 交给了一些有才华的贡献者.他们一直在推动它,并为我的设计缺陷找到了巧妙的解决方法.尽管面临挑战,我仍然感谢他们让项目保持良好状态.

---

**需要说明的是,React 中的热重新加载在今天非常有用.**事实上,这个博客使用 Gatsby,它使用了 React Hot Loader.我在我的编辑器中保存了这篇文章,它更新后没有刷新.魔法!在某些方面,我担心的主流用途的愿景已经几乎无聊了.

但是有很多人觉得它没有那么好.有些人认为它是一种噱头而且让我心碎了一点,但我认为他们真正说的是:**经验不是无缝的.**如果您不确定热重载是否有效,是否以令人困惑的方式打破,或者是否更容易刷新,那么这是不值得的.我同意这 100%,但对我而言,这意味着我们还有更多的工作要做.我很高兴开始考虑 React 对热重新加载的官方支持将来会是什么样子.

(如果你使用像 Elm,Reason 或 ClojureScript 这样的语言,也许这些问题已经在你的生态系统中得到解决.我很高兴你很高兴.这不会阻止我尝试并且不能为 JavaScript 带来好处.)

---

我想我已准备好再次尝试实施它.这就是原因.

自从`createClass`停止成为我们定义组件的主要方式,**热重组组件中复杂性和脆弱性的最大来源是动态替换类方法.**如何使用其方法的新"版本"修补现有的类实例?简单的答案是"在原型上替换它们",但即使使用 Proxies,根据我的经验,有太多的边缘情况可以让它可靠地工作.

相比之下,热重新加载功能很容易.Babel 插件可以将从模块导出的任何函数组件拆分为两个函数:

```jsx
// Reassigns the latest version
window.latest_Button = function(props) {
  // Your actual code is moved here by a plugin
  return <button>Hello</button>;
};

// Think of this as a "proxy"
// that other components would use
export default function Button(props) {
  // Always points to latest version
  return window.latest_Button(props);
}
```

每次编辑后该模块重新执行,`window.latest_Button`会指出最新的实施.重用相同的`Button`模块评估之间的功能会让我们欺骗 React 而不是卸载我们的组件,即使我们换掉了实现.

很长一段时间,在我看来,为功能实现可靠的热重装*单独*会鼓励人们编写复杂的代码,以避免使用类.但随着[Hooks](https://reactjs.org/docs/hooks-intro.html),功能组件功能齐全,所以这不再是一个问题.这种方法"适用于"Hooks:

```jsx{4}
// Reassigns the latest version
window.latest_Button = function(props) {
  // Your actual code is moved here by a plugin
  const [name, setName] = useState('Mary');
  const handleChange = e => setName(e.target.value);
  return (
    <>
      <input value={name} onChange={handleChange} />
      <h1>Hello, {name}</h1>
    </>
  );
};

// Think of this as a "proxy"
// that other components would use
export default function Button(props) {
  // Always points to latest version
  return window.latest_Button(props);
}
```

只要 Hook 调用顺序没有改变,我们就可以保持状态`window.latest_Button`在文件编辑之间替换.并且替换事件处理程序也"正常" - 因为 Hook 依赖于闭包,我们替换整个函数.

---

这只是一种可能方法的粗略草图.还有更多(有些是非常不同的).我们如何评估和比较它们?

在我过于依赖某种可能在某种程度上存在缺陷的具体方法之前,**我决定写下一些我认为对于判断组件代码的热重新加载实现很重要的原则.**

将这些原则中的一些表示为稍后的测试会很好.这些规则并不严格,可能会有合理的妥协.但是如果我们决定打破它们,那应该是一个明确的设计决定,而不是我们后来偶然发现的.

这里是我的热重新加载 React 组件的愿望清单:

### Correctness

- **在第一次编辑之前,热重新加载应该是不可观察的.**在保存文件之前,代码的行为应与禁用热重新加载时的行为完全相同.这是预期的事情`fn.toString()`不匹配,这已经是缩小的情况.但它不应该破坏合理的应用程序和库逻辑.

- **热重载不应该破坏 React 规则.**组件不应该以意外的方式调用它们的生命周期,意外地在不相关的树之间交换状态,或者执行其他非 Reacty 事务.

- **元素类型应始终与预期类型匹配.**一些方法包装组件类型,但这可能会破坏`<MyThing />.type === MyThing`.这是错误的常见来源,不应该发生.

- **应该很容易支持所有 React 类型.** `lazy`,`memo`,`forwardRef`- 他们都应该得到支持,并且不应该添加更多的支持.嵌套的变体如`memo(memo(...))`也应该工作.我们应该在类型形状发生变化时重新安装.

- **它不应该重新实现一个非平凡的 React 块.**很难跟上 React 的步伐.如果一个解决方案重新实现 React,它会在长期内带来问题,因为 React 增加了像 Suspense 这样的功能.

- **再出口不应该破裂.**如果组件从其他模块(无论是自己还是来自模块)重新导出组件`node_modules`),这不应该导致问题.

- **静态字段不应该破坏.**如果你定义一个`ProfilePage.onEnter`方法,您希望导入模块能够读取它.有时库依赖于此,因此重要的是可以读取和写入静态属性,并且组件本身可以"看到"相同的值.

- **丢失本地状态比行为不正确更好.**如果我们无法可靠地修补某些东西(例如,一个类),最好丢失它的本地状态,而不是在更新它时做一个混合成功的努力.无论如何,开发人员会怀疑并且可能会强制刷新.我们应该有意识地确定我们可以处理哪些案件,并放弃其余的案件.

- **丢失本地状态比使用旧版本更好.**这是先前原理的更具体的变化.例如,如果某个类无法热重新加载,则代码应该强制使用新版本重新安装这些组件,而不是继续渲染僵尸.

### Locality

- **编辑模块应该尽可能少地重新执行模块.**通常不鼓励在组件模块初始化期间产生副作用.但是你执行的代码越多,被调用两次就会导致混乱的可能性越大.我们正在编写 JavaScript,而 React 组件是(相对)纯度的岛屿,但即使在那里我们也没有强有力的保证.因此,如果我编辑模块,我的热重新加载解决方案应该重新执行该模块,并尝试在可能的情况下停止.

- **编辑组件不应该破坏其父母或兄弟姐妹的状态.**与如何相似`setState()`只影响下面的树,编辑组件不应该影响它上面的任何内容.

- **对非 React 代码的编辑应该向上传播.**如果使用从多个组件导入的常量或纯函数编辑文件,则应更新这些组件.在这些文件中丢失模块状态是可以接受的.

- **热重新加载期间引入的运行时错误不应传播.**如果你在一个组件中犯了错误,它不应该破坏你的整个应用程序.在 React 中,这通常通过错误边界来解决.然而,它们对于我们在编辑时产生的无数错别字来说太粗糙了.我应该能够在没有兄弟姐妹或父母卸载的情况下处理组件时制作和修复运行时错误.但是,错误*别*在热重载期间发生(并且在我的代码中是合法的错误)应该转到最接近的错误边界.

- **保留自己的状态,除非显然开发人员不想这样做.**如果您只是调整样式,那么状态会在每次编辑时重置都很令人沮丧.另一方面,如果你只是改变了状态形状或初始状态,你通常会喜欢它重置.默认情况下,我们应该尽力保持状态.但如果它在热重载期间导致错误,这通常是一些假设已经改变的迹象,所以我们应该重置状态和*重试*在那种情况下渲染.对事物进行评论和回顾是很常见的,因此优雅地处理它是很重要的.例如,删除 Hooks*在末尾*不应该重置状态.

- **当开发人员想要清楚时,丢弃状态.**在某些情况下,我们还可以主动检测用户是否想要重置.例如,如果 Hook 顺序改变了,或者原始 Hook 类似`useState`改变他们的初始状态类型.我们还可以提供一个轻量级注释,您可以使用它来强制组件在每次编辑时重置.如`// !`或者一些类似的约定,当您专注于组件的安装时,可以快速添加和删除.

- **支持更新"固定"的东西.**如果组件被包裹`memo()`,热重载应该仍然更新它.如果调用效果`[]`,它仍然应该被替换.代码就像一个看不见的变量.以前,我认为强制执行以下深层更新非常重要`renderRow={this.renderRow}`.但是在 Hooks 世界中,我们依赖闭合,无论如何这似乎是不必要的.不同的参考应该就足够了.

- **在一个文件中支持多个组件.**在同一文件中定义多个组件是一种常见模式.即使我们只保留函数组件的状态,我们也希望确保将它们放在一个文件中不会导致它们失去状态.注意这些可以是相互递归的.

- **在可能的情况下,保持儿童的状态.**如果你编辑一个组件,如果它的孩子无意中失去了状态,它总是令人沮丧.只要在其他文件中定义了子元素的元素类型,我们就希望保留它们的状态.如果它们在同一个文件中,我们应该尽最大努力.

- **支持自定义挂钩.**对于精心编写的自定义挂钩(有些情况如`useInterval()`可能有点棘手),热重新加载任何参数(包括函数)应该工作.这不应该需要额外的工作,而是从 Hooks 的设计中得出.我们的解决方案不应该妨碍.

- **支持渲染道具.**这通常不会造成问题,但值得验证它们是否正常工作并按预期更新.

- **支持更高阶的组件.**将导出包装到更高阶的组件中`connect`不应该破坏热重装或国家保护.如果您使用从 JSX 中的 HOC 创建的组件(例如`styled`),并且该组件是一个类,预计它在编辑文件中实例化时会丢失状态.但是,返回函数组件(可能使用 Hooks)的 HOC 即使在同一文件中定义也不应丢失状态.事实上,甚至编辑其论点(例如`mapStateToProps`)应该被反映出来.

### Feedback

- **成功和失败都应该提供视觉反馈.**您应该始终确信热重新加载是成功还是失败.在运行时或语法错误的情况下,您应该看到一个覆盖,它应该在不相关之后自动取消.当热重新加载成功时,应该有一些视觉反馈,例如刷新更新的组件或通知.

- **语法错误不应导致运行时错误或刷新.**当您编辑代码时,如果有语法错误,它应该显示在模式覆盖中(理想情况下,通过点击编辑器).如果出现另一个语法错误,则会更新现有覆盖.仅尝试热重新加载*之后*修复语法错误.语法错误不应使您失去状态.

- **重新加载后的语法错误应该仍然可见.**如果您看到模式语法错误覆盖和刷新,那么您仍然应该看到它.它绝对不应该让你运行上一个成功的版本(我在一些设置中看到过).

- **考虑公开超级用户工具.**通过热重载,代码本身可以是您的"终端".除了假设`// !`命令强制重新安装,例如`// inspect`命令显示一个面板,该面板在组件旁边具有 props 值.要有创造力!

- **尽量减少噪音.**devtools 和警告消息不应该公开我们正在做一些特殊的事情.避免破碎`displayName`或者在调试输出中添加无用的包装器.

- **在主要浏览器中调试应该显示最新的代码.**虽然这并不完全取决于我们,但我们应该尽最大努力确保浏览器调试器显示任何文件的最新版本,并且断点按预期工作.

- **为快速迭代而优化,重构时间不长.**这是 JavaScript,不是 ELM.任何长时间运行的系列编辑都可能不会很好地热重新加载,因为需要一个接一个地修复一系列错误.如果有疑问,请针对在紧密迭代循环中调整几个组件的用例进行优化,而不是针对大型重构进行优化.而且是可以预测的.请记住,如果您失去了开发人员的信任,他们无论如何都会刷新.

---

这是我的愿望清单,说明如何在 React 中热重新加载-或任何提供超过模板的组件系统-应该工作.随着时间的推移,我可能会在这里添加更多的内容.

我不知道我们可以用 JavaScript 实现多少目标.但还有一个原因,我期待着重新进行热加载.作为一名工程师,我比以前更有条理.特别地,**在深入到另一个实现之前,我终于学到了如何编写这样的需求的经验.**

也许这个真的能用!但如果没有,至少我为下一个尝试它的人留下了一些面包屑.
