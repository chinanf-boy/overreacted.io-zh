---
title: 'UI工程的元素'
date: '2018-12-30'
spoiler: 是什么让 UI 工程变得如此困难?
---

在我的[上篇 博文](/things-i-dont-know-as-of-2018/)中，我谈到，应承认我们的知识缺口。你可能会得出个结论，我建议解决平庸问题。不是的! 这可是一个广阔的领域。

我坚信你可以"从任何地方开始"，不需要以任何特定的顺序学习技术。但我也非常重视获得专业知识。就个人而言，我最感兴趣的是创建用户界面。

**我一直在考虑，我*所*知道并认为有价值的是什么。**当然，我熟悉一些技术(例如 JavaScript 和 React)。但是经验中，更为重要的教训是不容易就得到的。我从来没试过把它们说出来。这是我第一次尝试记载和描述其中一些东西。

---

有很多关于技术和库的"学习路线图"。哪个库将在 2019 年流行? 2020 年呢?你应该学习 Vue 还是 React? Angular? Redux 或 Rx 怎么样?你需要学习 Apollo 吗?REST 还是 GraphQL? 很容易迷路。如果连作者都错了，怎么办?

**我最大的学习突破不是特定的技术。**相反，当我努力解决特定的 UI 问题时，我学到了最多。有时候晚点，我就会发现那些可以帮助我的库或模式。在其他情况下，我会提出自己的解决方案(有好有坏)。

正是这种*问题*理解的结合，试验*解决方案*，并应用不同的*策略*，这导致了我生命中最有价值的学习经历。不过，**这篇文章只关注问题。**

---

如果您使用的是用户界面，那么您可能直接或使用库来处理至少其中一些挑战。在任何一种情况下，我都鼓励你创建一个*不带*库的小应用程序，以及复制和解决这些问题。任何一个问题，都没有一个最正确的解决方案。而学习探索问题空间，并尝试权衡不同的可能，才是对你最好的答案。

---

- **一致性。**你点击"赞(Like)"按钮，其文字更新:"你和其他 3 个朋友喜欢这篇文章."；你再次点击它，然后文本回退。听起来很容易。但也许这样的标签(label)存在于屏幕上的几个地方。也许还有一些需要改变的其他视觉提示(例如:按钮背景{background})。之前从服务器获取，并在悬停时可见的"喜欢者(“likers”)"列表，现在应包含您的姓名。如果你导航到另一个屏幕并返回，帖子不应该"忘记"它被喜欢。甚至局部的一致性，也会*单独*带来一系列挑战。但是其他用户，也可能修改我们显示的数据(例如，他们也喜欢，我们正在查看的帖子)。我们如何在屏幕的不同部分，同时保持数据的同步?我们又如何以及何时使本地数据与服务器保持一致，反之亦然?

- **响应性。**人们只能在有限的时间内，容忍他们缺乏视觉反馈的行为。对于*连续性*很强，像手势和滚动这样的动作，这个限制就很低。(甚至跳过一个 16ms 帧，都感觉"顿顿的"。)，而*间断性*像点击这样的动作，有研究称用户认为任何 `<100ms` 的延迟是可以接受的。如果操作需要更长时间，我们需要显示一个可视的指示器。但是有一些反直觉的挑战。导致页面布局"跳转"或经过多个加载"阶段"的指示符，会让操作比原来的*感觉更长*。类似地，以丢弃动画帧为代价的在 20ms 内处理交互，可能\*感觉比在 30ms 内处理它但没有丢帧的更慢。大脑并不是基准。那我们如何让我们的应用程序响应不同类型的输入?

* **等待时间。**计算和网络访问都需要时间。_有时_，如果它不会损害我们目标设备的响应能力(确保在低端设备频谱上测试您的应用程序)，我们可以忽略计算成本。但处理网络延迟是不可避免的 - 它可能需要几秒钟!我们的应用程序不能只是冻结以等待数据或代码加载。这意味着任何依赖于新数据，的代码或资源的操作都可能是异步的，需要处理"加载(loading)"情况。但几乎每个屏幕都会发生这种情况。我们如何优雅地处理延迟，而不显示 spinners 的"级联"或空"洞"? 我们如何避免"跳跃"布局? 我们如何在每次更改异步依赖的情况下，不需要"重写"代码?

* **导航。**我们希望，UI 与我们交互时，能保持"稳定"。事情不应该在我们眼皮底下消失。无论是在应用内启动(例如点击链接)还是由于外部事件(例如点击"后退"按钮)，导航也应该遵循这一原则。例如，在`/profile/likes`和`/profile/follows`选项卡之间切换后，profile 视图不应清除子视图外的搜索输入。甚至导航到*另一个*视图，就像走进一个房间。人们希望以后能，回去找到他们离开时的东西(也许还有一些新产品)。如果您处于 Feed 的 中间，点击个人资料，然后返回，发现你失去了 Feed 的位置， - 或者等待它再次加载，都会令人沮丧。我们如何构建我们的应用，在处理任意导航，不会丢失重要的上下文?

* **陈旧。**我们可以通过引入本地缓存，使"后退"按钮即时导航。在这样的缓存中，我们可以"记住"一些数据以便快速访问，即使，我们理论上可以重新网络请求它。但缓存会带来了自己的问题。缓存可能会变得陈旧。如果我更改了头像，它也应该在缓存中更新。如果我发布新帖子，则需要立即出现在缓存，否则缓存在需要时就会失效。这可能会让情况变得艰难且容易出错。如果发布失败怎么办? 在内存中缓存要保留多长时间? 当我们重新请求 Feed 时，我们是否要使用缓存的"拼接"上新获取的 Feed，或者将缓存内容丢弃? 缓存中如何表示分页或排序?

* **熵。** 热力学第二定律说"随着时间的推移，事情会变得一团糟"(好吧，不完全是这样)。对应到用户界面，我们无法预测确切的用户互动及其顺序。在任何时候，我们的应用程序都可能处于其中一个不可信的状态。我们尽最大努力，使结果可预测并受到我们设计的限制。我们不想查看错误截图，并想知道"怎么做*会*发生什么"。对*n*种可能的状态，就有*N×(N-1)*个过渡。例如，如果一个按钮有 5 种不同状态(正常，活动，悬停，危险，禁用)，并处在其中一种状态。那对该按钮的更新代码必须正确，这样才可以进行 5×4 = 20 次可能的状态切换 - 或禁止其中一些切换。我们如何驯服状态可能组合的爆炸量，并使视觉可预测输出?

* **优先。**有些事情就比其他事情来得重要。对话框可能需要物理地"出现"在产生它的按钮上方，并"突破"其容器的剪辑边界。新计划的任务(例如，响应一个点击)可能比已经开始的长期任务(例如，在屏幕折叠下方呈现，下一个帖子)更重要。随着我们的应用程序的增长，由不同的人和团队编写的部分代码会竞争有限的资源，如处理器，网络，屏幕区域和捆绑包的大小预算。有时候你可以在同等"重要性"的范围内对竞争者进行排名，比如 CSS 的`z-index`属性。[但结局，却少有好的.](https://blogs.msdn.microsoft.com/oldnewthing/20050607-00/?p=35413)每个开发人员都有偏见，总想着*自己*的代码很重要。如果一切都很重要，那其实就没什么是重要的了! 我们如何让独立的小部件*合作*，而不是争取资源?

* **无障碍性。** 的网站*不是*一个有利益问题。例如，在英国，残疾影响到了五分之一的人。[(这有份很好的信息图表.)](https://www.abrightclearweb.com/web-accessibility-in-the-uk/)我也亲自感受到了这一点。虽然我只有 26 岁，但我很难阅读薄字体和低对比度的网站。我有意地减少使用触控板的次数，而且我害怕有一天我必须通过键盘导航到差劲的网站。我们需要，让我们的应用程序对于有困难的人来说并不可怕 - 而好消息是，会有很多不出名的果实。它始于教育和工具。但我们还需要让它变得容易，方便让产品开发人员去做最正确的事情。我们可以做些什么，让无障碍变成*默认*行为，而不是事后的想法?

- **国际化。**我们的应用程序需要在世界各地工作。人们不仅会讲不同的语言，而且还需要，让产品工程师以最少的努力支持从右到左的布局。我们如何在不牺牲延迟和响应能力的情况下，支持不同的语言?

- **输送。**我们需要将应用程序代码提供给用户的计算机。我们使用什么样的传输和格式? 这可能听起来很简单，但这里有许多权衡。例如，原生应用程序倾向于以巨大的应用程序大小为代价，提前加载所有代码。Web 应用程序往往具有较小的初始负载，但代价是使用期间的延迟更长。我们如何选择引入延迟的时间点? 我们如何根据使用的模式优化输送? 我们需要什么样的数据，才能获得最佳解决方案?

- **弹性。**如果你是昆虫学家，你可能会喜欢虫子(Bug)，但你不会喜欢在你的程序中看到它们。但是，你的一些 bug 将不可避免地进入生产阶段。那么会发生什么? 一些 bugs 会让 定义明确的行为发生错误。例如，在某些情况下，您的代码可能会显示不正确的视觉输出。但是，如果渲染代码 _崩溃_ 了呢? 那我们将无法有意义地继续下去，因为视觉输出会不一致。渲染单个帖子的崩溃不应该"拖"整个 Feed 下水，或使其进入半破坏状态，从而导致进一步崩溃。我们如何以隔离渲染和获取失败的方式，编写代码，又可以保持应用程序的其余部分运行? 容错对用户界面意味着什么?

- **抽象。**在一个小应用程序中，我们可以对许多特殊情况进行硬编码，用来解决上述问题。但应用程序往往会增长。我们希望能够[reuse, fork, 和 join](/optimized-for-change/)我们的代码的一部分，并让集体一起工作。我们希望在不同人熟悉的部分之间定义明确的边界线，并避免使常变的逻辑过于僵化。我们如何创建隐藏特定 UI 部分的实现细节的抽象? 我们如何避免重新引入我们应用程序增长时，遇到的相同问题?

---

当然，还有很多问题，我没有提到。这份清单并非详尽无遗! 例如，我没有谈到设计师和工程协作，或调试和测试。也许下次吧。

带着特定视图库或数据提取库的解决方案，来阅读这些问题，会给人爽感感。但我鼓励你假装这些库不存在，并从这角度再次阅读。*您*会用什么方法去解决这些问题? 给他们一个小应用程序，作为尝试吧!(我很想在 GitHub 上看到你的实验 - 随时给我发推文回复。)

这些问题的有趣之处，在于它们大多数都能以任何规模出现。你可以在小型规模的部件中，看到它们，比如 typeahead 或 一个 tooltip，以及大型应用程序 Twitter 和 Facebook 等。

**想想您喜欢使用的应用程序中，非凡 UI 元素，并查看此问题列表。你能描述一下开发者选择的一些权衡吗? 尝试从头开始重新创建类似的行为!**

通过在小型应用程序中，试验这些问题而不使用库，我学到了很多关于 UI 工程的知识。我建议那些任何想要深入了解 UI 工程权衡的人去试一试。
